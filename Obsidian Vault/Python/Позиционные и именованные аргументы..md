Параметры, которые передаем внутри функции последовательно при ее вызове называются _позиционными_ 
```python
def final_price(price, discount):
    return price - price * discount / 100


print(final_price(1000, 5))
```

```python
950.0
```

В `python` можно задавать аргументы функций по умолчанию.
```python
def final_price(price, discount=1):
    return price - price * discount / 100


print(final_price(1000, 5))
# Значение скидки не задано, используется значение по умолчанию
print(final_price(1000))
```
Вывод программы:
```python
950.0
990.0
```
С аргументами по умолчанию стоит быть осторожным ведь они могут вызвать непредвиденные результатам
```python
def add_value(x, list_arg=[]):
    list_arg += [x]
    return list_arg


print(add_value(0))
print(add_value(0, [1, 2, 3]))
print(add_value(1))
```
Вывод: 
```python
[0]
[1, 2, 3, 0]
[0, 1]
```
При первом объявлении функции создается пустой список `list_arg`, потом к нему добавляется 0 и список имеет вид [0]. При втором вызове у меня `list_arg` переделывается в [1,  2, 3] => добавляется `0` => [1, 2, 3, 0]. При третьем вызове у меня сохранился список [0] и к нему присоединился `1` => [0, 1], что вообще не подразумевалось.

Чтоб решить эту проблему воспользуюсь `None`.
```python
def add_value(x, list_arg=None):
    if list_arg is None:
        list_arg = []
    list_arg += [x]
    return list_arg


print(add_value(0))
print(add_value(0, [1, 2, 3]))
print(add_value(1))
```
Вывод:
```python
[0]
[1, 2, 3, 0]
[1]
```
В программе при объявлении функции для аргумента `list_arg` создано значение по умолчанию `None`. При каждом вызове в функции сравнивается значение этого аргумента с `None`, и если это условие выполняется, то в аргумент записывается пустой список. Благодаря такому подходу значение аргумента по умолчанию можно искусственно присваивать заново.

Когда не помнишь в каком порядки передать аргументы в функцию, то через равно указываем имя аргумента потом значения. Такие аргументы называются именованными. 
```python
def final_price(price, discount=1):
    return price - price * discount / 100


print(final_price(1000, discount=5))
print(final_price(discount=10, price=1000))
```
Вывод: 
```python
950.0
900.0
```

Есть функции в которые можно передавать неограниченное количество аргументов, например функция `print`. Чтобы воплотить эту идею в своих функциях нужно при объявлении поставить `*` перед аргументом. К примеру, `*args`. В функции этот аргумент будет кортежем, содержащим переданные значения позиционных аргументов.
```python
def final_price(*prices, discount=1):
    return [price - price * discount / 100 for price in prices]


print(final_price(100, 200, 300, discount=5))
```
Вывод: 

```python
[95.0, 190.0, 285.0]
```

Чтобы функция могла принимать неограниченное количество именованных аргументов, нужно при её объявлении поставить аргумент с `**`. Например, `**kwargs` (сокращение от keyword arguments). В функции этот аргумент будет словарём, ключи которого будут строками, содержащими имена передаваемых аргументов, а значения по ключам будут соответствовать значениям передаваемых аргументов.
```python
def final_price(*prices, discount=1, **kwargs):
    low = kwargs.get("price_low", min(prices))
    high = kwargs.get("price_high", max(prices))
    return [price - price * discount / 100 for price in prices if low <= price <= high]


print(final_price(100, 200, 300, 400, 500, discount=5))
print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200))
print(final_price(100, 200, 300, 400, 500, discount=5, price_high=200))
print(final_price(100, 200, 300, 400, 500, discount=5, price_low=200, price_high=350))
```
Вернём список только рассчитанных со скидкой цен. Границы диапазона будут передаваться в аргументах `price_low` и `price_high`. Если нижняя или правая граница не передана, то используем минимальную и максимальную стоимость из позиционных аргументов.
```python
[95.0, 190.0, 285.0, 380.0, 475.0]
[190.0, 285.0, 380.0, 475.0]
[95.0, 190.0]
[190.0, 285.0]
```
