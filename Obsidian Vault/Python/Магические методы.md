>Они нужны для описания взаимодействия с объектами при помощи стандартных операций и встроенных функций. 

 Описание специальных методов называется **перегрузкой операторов** (operator overloading).
У магических методах слева и справа есть `__` .

**Список некоторых методов:**
- Метод `__repr__` вызывается стандартной функцией `repr` и возвращает строку, которая является представлением объекта в формате инициализации. 

	```python
    def __repr__(self):
        return f"Point({self.x}, {self.y})"
        
print(repr(point))  # Выводит: "Point(3, 4)"
```


```
- Методы для операций сравнения:
    - `__lt__(self, other)` — `<`;
    - `__le__(self, other)` — `<=`;
    - `__eq__(self, other)` — `==`;
    - `__ne__(self, other)` — `!=`;
    - `__gt__(self, other)` — `>`;
    - `__ge__(self, other)` — `>=`.
- Метод `__call__(arg1, arg2, ...)` вызывается, когда сам объект вызывается как функция с аргументами.
- Методы для работы с объектом как с коллекцией:
    - `__getitem__(self, key)` используется для получения элемента коллекции по ключу `self[key]`;
    - `__setitem__(self, key, value)` используется для записи значения по ключу `self[key] = value`;
    - `__delitem__(self, key)` используется для удаления ключа и соответствующего ему значения;
    - `__len__(self)` вызывается стандартной функцией `len`;
    - `__contains__(self, item)` вызывается при проверке принадлежности значения `item` объекту-коллекции `self` с помощью оператора `in`.
- Математические операции:
    - `__add__(self, other)` — `self + other`;
    - `__sub__(self, other)` — `self - other`;
    - `__mul__(self, other)` — `self * other`;
    - `__matmul__(self, other)` — `self @ other`;
    - `__truediv__(self, other)` — `self / other`;
    - `__floordiv__(self, other)` — `self // other`;
    - `__mod__(self, other)` — `self % other`;
    - `__divmod__(self, other)` — `divmod(self, other)`;
    - `__pow__(self, other)` — `self ** other`;
    - `__lshift__(self, other)` — `self << other`;
    - `__rshift__(self, other)` — `self >> other`;
    - `__and__(self, other)` — `self & other`;
    - `__xor__(self, other)` — `self ^ other`;
    - `__or__(self, other)` — `self | other`;
    - `__radd__(self, other)` — `other + self`;
    - `__rsub__(self, other)` — `other - self`;
    - `__rmul__(self, other)` — `other * self`;
    - `__rmatmul__(self, other)` — `other @ self`;
    - `__rtruediv__(self, other)` — `other / self`;
    - `__rfloordiv__(self, other)` — `other // self`;
    - `__rmod__(self, other)` — `other % self`;
    - `__rdivmod__(self, other)` — `divmod(other, self)`;
    - `__rpow__(self, other)` — `other ** self`;
    - `__rlshift__(self, other)` — `other << self`;
    - `__rrshift__(self, other)` — `other >> self`;
    - `__rand__(self, other)` — `other & self`;
    - `__rxor__(self, other)` — `other ^ self`;
    - `__ror__(self, other)` — `other | self`;
    - `__iadd__(self, other)` — `self += other`;
    - `__isub__(self, other)` — `self -= other`;
    - `__imul__(self, other)` — `self *= other`;
    - `__imatmul__(self, other)` — `self @= other`;
    - `__itruediv__(self, other)` — `self /= other`;
    - `__ifloordiv__(self, other)` — `self //= other`;
    - `__imod__(self, other)` — `self %= other`;
    - `__ipow__(self, other)` — `self **= other`;
    - `__ilshift__(self, other)` — `self <<= other`;
    - `__irshift__(self, other)` — `self >>= other`;
    - `__iand__(self, other)` — `self &= other`;
    - `__ixor__(self, other)` — `self ^= other`;
    - `__ior__(self, other)` — `self |= other`.
 
 Пример реализации этих методов:
 ```python
class A:

    def __init__(self):
        self.value = 10

    def __add__(self, other):
        return "Выполняется метод __add__."

    def __radd__(self, other):
        return "Выполняется метод __radd__."

    def __iadd__(self, other):
        self.value += other
        return self

    def __str__(self):
        return f"value: {self.value}."

        
a = A()
print(a + 1)
print(1 + a)
a += 1
print(a)
```

Вывод программы:

```
Выполняется метод __add__.
Выполняется метод __radd__.
value: 11.
```