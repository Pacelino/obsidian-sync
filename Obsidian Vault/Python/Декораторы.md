>Эта штука расширяет возможности функции, не меняя исходный код функции.

Принцип работы: 
Принимает функцию => 
Объявляет новую функцию, которая расширяет функция которую принял => 
Возвращает новую функцию как аргумент.

Декоратор `count()`, который будет добавлять количество ее вызовов исходной функции к ее результату. Обернем функцию `hello()`.
```python
# Декоратор принимает функцию f как аргумент
def count(f):
    total = 0

    # Объявляем функцию, которая расширяет функционал f
    def decorated(*args, **kwargs):
	# Переменная total объявлена нелокальной для доступа из внутренней функции
        nonlocal total
        total += 1
        # Возвращаем значение исходной функции и дополнительно total
        return f(*args, **kwargs), total
    # Возвращаем новую функцию как объект
    return decorated


@count
def hello(name):
    return f"Привет, {name}!"


print(hello("Пользователь_1"))
print(hello("Пользователь_2"))
```
Вывод:
```
('Привет, Пользователь_1!', 1)
('Привет, Пользователь_2!', 2)
```
**Как это работает
1. При вызове декоратора на функцию, сначала выполняется код декоратора `def decorated`.
2. Выполняется код самой функции.
3. Также декоратор может выполнять код после выполнения функции.
4. Результат выполнения функции (или обернутой функции) возвращается вызывающему коду.


Аргумент в `f` в `count()` это наша функция, которую будем оборачивать (т.е `hello()`). 
С помощью `nonlocal` говорим, что переменная `total` нелокальная. Это нужно чтобы ее использовать в `decarated()`. 
`*args` и `**kwargs` нужны для возможности оборачивать функции с аргументами.