```
import numpy as np
```

В программе мы сможем обращаться к `numpy` по новому имени — `np`. Это упростит чтение кода.

Библиотека `numpy` работает с объектами-массивами, которые способны хранить много значений и быть многомерными. При этом, в отличие от списков, массивы могут хранить только значения одного типа.

Для создания массива можно использовать `array(iterator)`
```python
a = np.array([1, 2, 3, 4])
b = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
print(f"a[0] = {a[0]}") # a[0] = 1
print(f"b[0] = {b[0]}") # b[0] = [1 2]
```
В нашем примере массив `a` имеет размерность, равную 1. Размерность массива `b` равна 2. В терминологии `numpy` массив `a` имеет одну ось (термин «axis» из документации) длиной четыре элемента, а массив `b` имеет две оси: первая имеет длину 4, а длина второй оси равна 2.

Массивы `numpy` являются объектами класса `ndarray`. Наиболее важными атрибутами класса `ndarray` являются:
- `ndarray.ndim` — размерность (количество осей) массива;
- `ndarray.shape` — кортеж, значения которого содержат количество элементов по каждой из осей массива;
- `ndarray.size` — общее количество элементов массива;
- `ndarray.dtype` — объект, описывающий тип данных элементов массива;
- `ndarray.itemsize` — размер памяти в байтах, занимаемый одним элементом массива.
```python
a = np.array([[1, 2], [3, 4], [5, 6], [7, 8]])
print(f"a.ndim = {a.ndim}, a.shape = {a.shape}, a.size = {a.size}, a.dtype = {a.dtype}")
```
Вывод:
```
a.ndim = 2, a.shape = (4, 2), a.size = 8, a.dtype = int32
```

>Встроенные в `numpy` типы данных аналогичны типам данных в языке программирования С.

`np.zeros()` - для создания массива из нулей. Принимает кортеж с количеством чисел, соответствующим количеству осей массива, а значения в кортеже — количество элементов по каждой из осей.
```python
a = np.zeros((4, 3))
print(a)
print()
a = np.zeros((4, 3), dtype="int32")
print(a)
```
Вывод:
```
[[0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]
 [0. 0. 0.]]

[[0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]]
```

`np.ones()` - создаёт массив аналогично функции `np.zeros()`, только из элементов-единиц.
```python
a = np.ones((4, 3))
print(a)
```

```
[[1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]
 [1. 1. 1.]]
```

`np.eye()` - создаёт единичную матрицу, то есть массив с единицами на главной диагонали и нулевыми остальными элементами.
```python
a = np.eye(5, 5, dtype="int8")
print(a)
```

```
[[1 0 0 0 0]
 [0 1 0 0 0]
 [0 0 1 0 0]
 [0 0 0 1 0]
 [0 0 0 0 1]]
```

`np.arange()` - Для создания массива, заполненного значениями из диапазона.
```python
a = np.arange(1, 10)
print(a)
a = np.arange(1, 5, 0.4)
print(a)
```

```
[1 2 3 4 5 6 7 8 9]

[1.  1.4 1.8 2.2 2.6 3.  3.4 3.8 4.2 4.6]
```

`np.linspace()` - оздаёт массив из заданного количества вещественных равномерно распределённых значений.
```python
a = np.linspace(1, 5, 10)  # задаётся начало, конец диапазона и количество значений
print(a)
```

```
[1.         1.44444444 1.88888889 2.33333333 2.77777778 3.22222222
 3.66666667 4.11111111 4.55555556 5.        ]
```

`reshape()` - изменения размерности массива.
```python
a = np.zeros((4, 3), dtype="uint8")
print(a)
print()
a = a.reshape((2, 6))
print(a)
```

```
[[0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]]

[[0 0 0 0 0 0]
 [0 0 0 0 0 0]]
```

Если при изменении размерности указать значение -1 по одной или нескольким осям, то значения размерности рассчитаются автоматически:
```
[[0 0 0]
 [0 0 0]
 [0 0 0]
 [0 0 0]]

[[[0 0]
  [0 0]
  [0 0]]

 [[0 0]
  [0 0]
  [0 0]]]
```

>При работы с массивами доступны все арифметические операции, а также тригонометрические, экспоненциальная и другие функции.. Для корректного их выполнения они должны быть одинакового размера.  Выполнения математических операций происходит поэлементно. 

```python
a = np.array([9, 8, 7])
b = np.array([1, 2, 3])
print(a + b)
print(a - b)
print(a * b)
print(a / b)
```

```
[10 10 10]
[8 6 4]
[ 9 16 21]
[9.         4.         2.33333333]
```

Для умножения матриц используется операция `@` или функция `dot`:
```python
a = np.array([[1, 2, 3],
              [4, 5, 6],
              [7, 8, 9]])
b = np.array([[0, 0, 1],
              [0, 1, 0],
              [1, 0, 0]])
print(a @ b)
```

```
[[3 2 1]
 [6 5 4]
 [9 8 7]]
```

`transpose()` - транспонирование матриц.
`rot90()` - поворачивать матрицу.
```python
a = np.arange(1, 13).reshape(4, 3)
print(a)
print("Транспонирование")
print(a.transpose())
print("Поворот вправо")
print(np.rot90(a))
print("Поворот влево")
print(np.rot90(a, -1))
```

```
[[ 1  2  3]
 [ 4  5  6]
 [ 7  8  9]
 [10 11 12]]
Транспонирование
[[ 1  4  7 10]
 [ 2  5  8 11]
 [ 3  6  9 12]]
Поворот вправо
[[ 3  6  9 12]
 [ 2  5  8 11]
 [ 1  4  7 10]]
Поворот влево
[[10  7  4  1]
 [11  8  5  2]
 [12  9  6  3]]
```

Функции вычисления суммы элементов массива, поиска минимального и максимального элементов и многие другие по умолчанию работают для всех элементов массива, не учитывая размерность
```python
a = np.array([[1, 2, 3],
             [4, 5, 6],
             [7, 8, 9]])
print(a.sum())
print(a.min())
print(a.max())
```

```
45
1
9
```

В массивах можно брать срез. Работает так же как у обычных списках. 
Можно взять срез отдельной части матрицы, указав, какие строки и столбцы должны попасть в срез.
```python
a = np.arange(1, 13).reshape(3, 4)
print(a)
print()
print(a[:2, 2:])
print()
print(a[:, ::2])
```

```
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]

[[3 4]
 [7 8]]

[[ 1  3]
 [ 5  7]
 [ 9 11]]
```

Для линеаризации многомерного массива можно использовать атрибут `flat`, который является итератором, возвращающим последовательно значения массива

```python

a = np.arange(1, 13).reshape(3, 4)
print(a)
print()
print("; ".join(str(el) for el in a.flat))
```

```
[[ 1  2  3  4]
 [ 5  6  7  8]
 [ 9 10 11 12]]

1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12
```