**Обработка исключения**
```python
print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))
```
Допустим введем диапазон от -1 до 1. 
Программа выдаст ошибку `ZeroDivisionError: division by zero`. Что означает, что программа попыталась поделить 1 на 0. Такой тип ошибок называется **исключением**. 

>Существует подход для работы с ошибками: Easier to Ask Forgiveness than Permission (EAFP), или «Проще попросить прощения, чем разрешения». В таком подходе сначала исполняется код, а в случае возникновение ошибки она обрабатывается. Такой подход реализуется с помощью обработок исключений.

Для обработки исключения используется следующий синтаксис:
```python
try:
    <код , который может вызвать исключения при выполнении>
except <класс исключения_1(какая ошибка может вылететь)>:
    <код обработки исключения(что делаем при возникновении этой ошибки)>
except <класс исключения_2>(какая ошибка может вылететь):
    <код обработки исключения(что делаем при возникновении этой ошибки)>
...
else:
    <код выполняется, если не вызвано исключение в блоке try>
finally:
    <код , который выполняется всегда>
```
Необязательный блок `else` выполняет код в случае, если в блоке `try` не вызвано исключение.

Выполняя обработку исключений, следует обрабатывать сначала узкие ошибки, потом более общие. 
```python
try:
    print(1 / int(input()))
except ZeroDivisionError:
    print("Ошибка деления на ноль.")
except ValueError:
    print("Невозможно преобразовать строку в число.")
except Exception:
    print("Неизвестная ошибка.")
else:
    print("Операция выполнена успешно.")
finally:
    print("Программа завершена.")

```
Блок `finally` выполняется всегда.

Пример:
```python
try:
    print(";".join(str(1 / x) for x in range(int(input()), int(input()) + 1)))
except ZeroDivisionError:
    print("Диапазон чисел содержит 0.")
except ValueError:
    print("Необходимо ввести два числа.")
```
Исключения можно принудительно вызывать с помощью оператора `raise`. Этот оператор имеет следующий синтаксис:

`raise <класс исключения>(параметры)`
```python
def divide_two_numbers(a: float, b: float) -> float:
    if b == 2:
        raise ValueError("Я не буду делить число на 2")
    return a / b
```
В качестве параметра можно, например, передать строку с сообщением об ошибке.
Также можно создавать [[Собственные исключения]]

Для получения доступа к ошибке напишем
```python
try:
	divide_two_numbers(43, 2)
except ValueError as e:
	print(str(e))
```
В `e` будет храниться объект исключения `ValueError`.
### Частые исключения 
- `KeyError` - получение значения по не существующему ключу
- `IndexError` - получение значения по не существющему индексу
- `TypeError` - когда совершаем операцию не над тем типом
- `ValueError` - по типу параметр подходит, но не по значению (Например: передача отрицательного id) 

### traceback
```python 
import traceback
```
Это модуль, который позволяет видет какие функции вызываели до ислючения
```python
import traceback

def divide_two_numbers(a: float, b: float) -> float:
    if b == 2:
        raise ValueError("Я не буду делить число на 2")
    return a / b
    
try:
    print(divide_two_numbers(32, 2))
except ValueError as e:
    msg = traceback.format_exc()
    print(msg)
```

В `msg` сохранили что было до текущей функции. Эту штуку можно сохранить в логи или отправить на почту. 