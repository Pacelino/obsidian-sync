### Статический метод
Если метод не использует никаких данных экземпляра класса и никаких данных самого класса, то такой метод - **статический**. Статический метод можно задать конструкцией @staticmethod

Например:
```python
class User:
...
@staticmethod
def is_full_name(name: str) -> bool:
	return len(name.split()) > 1
```
У этого метода нет аргумента `self`, то есть он не имеет доступа к экземпляру класса. 

Вызвать этот метод можно от экземпляра класса и от самого класса
```python
some_custom_user = User()
some_custom_user.is_full_name("Dima Boronin")
User.is_full_name("Petr")
```

Создание функции как статической, просто говорит о принадлежности логики этой функции к классу. 

### Методы класса
>Такой же, как и статический метод, не имеет доступ к экземпляру класса, но зато имеют доступ к самому классу.

```python
class User:
    USERS_COUNT = 0
    def __init__(self):
        User.USERS_COUNT += 1
        
    @classmethod
    def how_much_users(cls):
    return cls.USERS_COUNT
```

Константа `USERS_COUNT` относится именно к классу, а не к экземпляру класса. 
`cls` - сам класс. 
Пример работы:
```python
user1 = User()
user2 = User()

print(User.USERS_COUNT) # получит доступ к атрибуту класса, напечатает 2
print(user1.USERS_COUNT) # тоже получит доступ к тому же атрибуту, напечатает 2
```

Используем этот метод в момент, когда хотим создать метод не работающий с экземпляром класса. Но его логика связана с классом и он может использовать атрибуты класса. 

### В иготе:
- обычный метод имеет доступ к атрибутам экземпляра класса через self
- статический метод (staticmethod) не имеет доступа ни к атрибутам экземпляра класса через self, ни к атрибутам самого класса через cls
- метод класса (classmethod) имеет доступ к атрибутам класса через cls, но не имеет доступ к экземпляру класса через self.